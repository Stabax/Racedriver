
//sha.cpp

#include "sha.h"


//constructeurs
SHA256::SHA256() : sha256_k({1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748,  2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882,  2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,  1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800,  3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298}), m_h({3144134277, 1013904242,  2773480762, 1359893119, 2600822924, 528734635, 1541459225}), m_len(0), m_tot_len(0), SHA224_256_BLOCK_SIZE(512/8)
{

}

//destructeur
SHA256::~SHA256()
{

}



//méthodes statiques
std::string SHA256::sha256(std::string input, std::string salt)
{
	input += salt;
	
	const unsigned int DIGEST_SIZE(256 / 8);
	unsigned char digest[DIGEST_SIZE];
	memset(digest,0,DIGEST_SIZE);

	SHA256 ctx = SHA256();
	ctx.update( (unsigned char*)input.c_str(), input.length());
	ctx.final(digest);

	char buf[2*DIGEST_SIZE+1];
	buf[2*DIGEST_SIZE] = 0;
	for (unsigned short int i = 0; i < DIGEST_SIZE; i++)
	{
		sprintf(buf+i*2, "%02x", digest[i]);
	}
	
	return std::string(buf);
}



//accesseurs



//mutateurs



//méthodes
void SHA256::update(const unsigned char *message, unsigned int len)
{
	unsigned int block_nb;
	unsigned int new_len, rem_len, tmp_len;
	const unsigned char *shifted_message;
	
	tmp_len = SHA224_256_BLOCK_SIZE - m_len;
	rem_len = len < tmp_len ? len : tmp_len;
	memcpy(&m_block[m_len], message, rem_len);
	
	if (m_len + len < SHA224_256_BLOCK_SIZE) 
	{
		m_len += len;
		return;
	}
	
	new_len = len - rem_len;
	block_nb = new_len / SHA224_256_BLOCK_SIZE;
	shifted_message = message + rem_len;
	transform(m_block, 1);
	transform(shifted_message, block_nb);
	rem_len = new_len % SHA224_256_BLOCK_SIZE;
	memcpy(m_block, &shifted_message[block_nb << 6], rem_len);
	m_len = rem_len;
	m_tot_len += (block_nb + 1) << 6;
}


void SHA256::transform(const unsigned char *message, unsigned int block_nb)
{
	unsigned long w[64];
	unsigned long wv[8];
	unsigned long t1, t2;
	const unsigned char *sub_block;
	int i;
	int j;
	
	for (i = 0; i < (int) block_nb; i++)
	{
		sub_block = message + (i << 6);
		
		for (j = 0; j < 16; j++) 
		{
			SHA2_PACK32(&sub_block[j << 2], &w[j]);
		}
		for (j = 16; j < 64; j++) 
		{
			w[j] =  SHA256_F4(w[j -  2]) + w[j -  7] + SHA256_F3(w[j - 15]) + w[j - 16];
		}
		for (j = 0; j < 8; j++) 
		{
			wv[j] = m_h[j];
		}
		for (j = 0; j < 64; j++) 
		{
			t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6]) + sha256_k[j] + w[j];
			t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);
			wv[7] = wv[6];
			wv[6] = wv[5];
			wv[5] = wv[4];
			wv[4] = wv[3] + t1;
			wv[3] = wv[2];
			wv[2] = wv[1];
			wv[1] = wv[0];
			wv[0] = t1 + t2;
		}
		for (j = 0; j < 8; j++) 
		{
			m_h[j] += wv[j];
		}
	}
}


void SHA256::final(unsigned char *digest)
{
	unsigned int block_nb;
	unsigned int pm_len;
	unsigned int len_b;
	int i;
	
	block_nb = (1 + ((SHA224_256_BLOCK_SIZE - 9) < (m_len % SHA224_256_BLOCK_SIZE)));
	len_b = (m_tot_len + m_len) << 3;
	pm_len = block_nb << 6;
	memset(m_block + m_len, 0, pm_len - m_len);
	m_block[m_len] = 0x80;
	SHA2_UNPACK32(len_b, m_block + pm_len - 4);
	transform(m_block, block_nb);
	
	for (i = 0 ; i < 8; i++) 
	{
		SHA2_UNPACK32(m_h[i], &digest[i << 2]);
	}
}



//opérateurs méthodes ( =, (), [] )



//opérateurs non méthodes (+, ++, -, --, +=, -=, /=, *=, %=, +, -, *, /, %, ==, !=, <, >, <=, >=, <<, >> ) 



