
Règles en programmation objet:



Généralités:

-Encapsulation: les attributs ne doivent jamais être public, ils doivent être protected ou private. On encapsule un comportement, pas des propriétés. Ainsi, si un algorithme utilise les données d'une classe ou accessibles via cette classe, alors cet algorithme doit être encapsulé dans cette classe.
-Loi de Déméter: un objet A peut appeler une méthode d'un objet B, mais A ne peut pas utiliser B pour accéder à un troisième objet C et appeler ses méthodes. Ainsi, les méthodes d'un objet ne peuvent appeler que des méthodes provenant: -de cet objet, -d'autres objets instanciés par cet objet, -des objets qui lui sont envoyés en argument dans une méthode, -de ses attributs (si certains sont des objets) mais pas des attributs de ces attributs, -des objets à portée globale (exemple: std::cout). 
-Loi de Déméter: Les accesseurs ne doivent pas retourner d'objets.
-S.O.L.I.D: Une classe ne doit avoir qu'une seule responsabilité.
-S.O.L.I.D: Une classe doit être ouverte à l'extention (héritage) mais fermée à la modification.
-L'existence d'au moins une classe "gestionnaire" dans une architecture orientée objet démontre l'existence de problèmes dans cette architecture.


Héritage:

-S.O.L.I.D: il doit être possible d'utiliser un objet d'une classe dérivée partout où l'on peut utiliser un objet d'une de ses classes mères.
-il doit être possible de faire une affectation d'une classe dérivée vers une classe mère (obj_classe_mere = obj_classe_fille;).
-un pointeurs sur une classes dérivées doit être compatible avec un pointeurs sur une de ses classes mères. Cela signifie qu'il est possible d'affecter un pointeur de classe dérivée à un pointeur d'une de ses classes de base (classe_mere* obj_classe_mere = &obj_class_fille)
-S.O.L.I.D: Une classe ne doit pas hériter d'une ou plusieurs classe(s) qui lui est (sont) inutile(s) (l'héritage multiple est souvent la solution). Il faut privilégier plusieurs petites interfaces plutot qu'une grosse interface généralisée.


Si le destructeur, le constructeur par copie, ou l'opérateur d'assignement doit être défini (si un des attributs est un pointeur):

-SOIT il faut suivre là règle des quatres (définir ces 3 méthodes ET le constructeur par déplacement) ==> SUIVRE L'IDIOME DU COPY AND SWAP.
-SOIT il faut supprimer les méthode inutiles parmis ces 3 méthodes (faire suivre leur prototype par =delete;).


Notions avancées:

-Seuls les attributs des entités peuvent être comparées, pas les entités elles-mêmes (utiliser des méthodes pour comparer, pas des opérateurs de comparaison)
-Les entités de doivent pas définir d'opérateurs de comparaison ni d'opérateur arithmétique.
-Les entités ne doivent jamais êtres reçues par valeur, mais par références.
-Les entités doivent supprimer le constructeur par copie, le construtueur par mouvement, l'opérateur d'assignement, et l'opérateur de mouvement (faire suivre leur prototype par =delete;).
-Les valeurs doivent avoir le constructeur par défaut (il faut donc le définir si une surcharge du constructeur existe) et l'opérateur d'égalité
